// Package dbmodel contains generated code for schema 'public'.
package dbmodel

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"time"

	pgtype "github.com/jackc/pgx/v5/pgtype"
	_ "github.com/jackc/pgx/v5/stdlib" // pgx postgres driver
	"github.com/samber/lo"
)

// Collection represents a row from 'public.collections'.
type Collection struct {
	ID                   int64              `json:"id" db:"id"`                                         // id
	Status               int                `json:"status" db:"status"`                                 // status
	RequestCountLimit    int                `json:"request_count_limit" db:"request_count_limit"`       // request_count_limit
	RequestDurationLimit time.Duration      `json:"request_duration_limit" db:"request_duration_limit"` // request_duration_limit
	Criteria             []byte             `json:"criteria" db:"criteria"`                             // criteria
	RequestCount         int                `json:"request_count" db:"request_count"`                   // request_count
	CreatedAt            time.Time          `json:"created_at" db:"created_at"`                         // created_at
	StartedAt            pgtype.Timestamptz `json:"started_at" db:"started_at"`                         // started_at
	UpdatedAt            pgtype.Timestamptz `json:"updated_at" db:"updated_at"`                         // updated_at
	CompletedAt          pgtype.Timestamptz `json:"completed_at" db:"completed_at"`                     // completed_at
	ResultID             pgtype.Text        `json:"result_id" db:"result_id"`                           // result_id
	ErrorMessage         pgtype.Text        `json:"error_message" db:"error_message"`                   // error_message
	ErrorCode            pgtype.Int4        `json:"error_code" db:"error_code"`                         // error_code
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [Collection] exists in the database.
func (c *Collection) Exists() bool {
	return c._exists
}

// Deleted returns true when the [Collection] has been marked for deletion
// from the database.
func (c *Collection) Deleted() bool {
	return c._deleted
}

// Insert inserts the [Collection] to the database.
func (c *Collection) Insert(ctx context.Context, db DB) error {
	switch {
	case c._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case c._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO public.collections (` +
		`status, request_count_limit, request_duration_limit, criteria, request_count, created_at, started_at, updated_at, completed_at, result_id, error_message, error_code` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12` +
		`) RETURNING id`
	// run
	logf(sqlstr, c.Status, c.RequestCountLimit, c.RequestDurationLimit, c.Criteria, c.RequestCount, c.CreatedAt, c.StartedAt, c.UpdatedAt, c.CompletedAt, c.ResultID, c.ErrorMessage, c.ErrorCode)
	if err := db.QueryRow(ctx, sqlstr, c.Status, c.RequestCountLimit, c.RequestDurationLimit, c.Criteria, c.RequestCount, c.CreatedAt, lo.Ternary(c.StartedAt.Valid == false, nil, &c.StartedAt), lo.Ternary(c.UpdatedAt.Valid == false, nil, &c.UpdatedAt), lo.Ternary(c.CompletedAt.Valid == false, nil, &c.CompletedAt), lo.Ternary(c.ResultID.Valid == false, nil, &c.ResultID), lo.Ternary(c.ErrorMessage.Valid == false, nil, &c.ErrorMessage), lo.Ternary(c.ErrorCode.Valid == false, nil, &c.ErrorCode)).Scan(&c.ID); err != nil {
		return logerror(err)
	}
	// set exists
	c._exists = true
	return nil
}

// Update updates a [Collection] in the database.
func (c *Collection) Update(ctx context.Context, db DB) error {
	switch {
	case !c._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case c._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.collections SET ` +
		`status = $1, request_count_limit = $2, request_duration_limit = $3, criteria = $4, request_count = $5, created_at = $6, started_at = $7, updated_at = $8, completed_at = $9, result_id = $10, error_message = $11, error_code = $12 ` +
		`WHERE id = $13`
	// run
	logf(sqlstr, c.Status, c.RequestCountLimit, c.RequestDurationLimit, c.Criteria, c.RequestCount, c.CreatedAt, c.StartedAt, c.UpdatedAt, c.CompletedAt, c.ResultID, c.ErrorMessage, c.ErrorCode, c.ID)
	if _, err := db.Exec(ctx, sqlstr, c.Status, c.RequestCountLimit, c.RequestDurationLimit, c.Criteria, c.RequestCount, c.CreatedAt, lo.Ternary(c.StartedAt.Valid == false, nil, &c.StartedAt), lo.Ternary(c.UpdatedAt.Valid == false, nil, &c.UpdatedAt), lo.Ternary(c.CompletedAt.Valid == false, nil, &c.CompletedAt), lo.Ternary(c.ResultID.Valid == false, nil, &c.ResultID), lo.Ternary(c.ErrorMessage.Valid == false, nil, &c.ErrorMessage), lo.Ternary(c.ErrorCode.Valid == false, nil, &c.ErrorCode), c.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [Collection] to the database.
func (c *Collection) Save(ctx context.Context, db DB) error {
	if c.Exists() {
		return c.Update(ctx, db)
	}
	return c.Insert(ctx, db)
}

// Upsert performs an upsert for [Collection].
func (c *Collection) Upsert(ctx context.Context, db DB) error {
	switch {
	case c._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.collections (` +
		`id, status, request_count_limit, request_duration_limit, criteria, request_count, created_at, started_at, updated_at, completed_at, result_id, error_message, error_code` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`status = EXCLUDED.status, request_count_limit = EXCLUDED.request_count_limit, request_duration_limit = EXCLUDED.request_duration_limit, criteria = EXCLUDED.criteria, request_count = EXCLUDED.request_count, created_at = EXCLUDED.created_at, started_at = EXCLUDED.started_at, updated_at = EXCLUDED.updated_at, completed_at = EXCLUDED.completed_at, result_id = EXCLUDED.result_id, error_message = EXCLUDED.error_message, error_code = EXCLUDED.error_code `
	// run
	logf(sqlstr, c.ID, c.Status, c.RequestCountLimit, c.RequestDurationLimit, c.Criteria, c.RequestCount, c.CreatedAt, c.StartedAt, c.UpdatedAt, c.CompletedAt, c.ResultID, c.ErrorMessage, c.ErrorCode)
	if _, err := db.Exec(ctx, sqlstr, c.ID, c.Status, c.RequestCountLimit, c.RequestDurationLimit, c.Criteria, c.RequestCount, c.CreatedAt, lo.Ternary(c.StartedAt.Valid == false, nil, &c.StartedAt), lo.Ternary(c.UpdatedAt.Valid == false, nil, &c.UpdatedAt), lo.Ternary(c.CompletedAt.Valid == false, nil, &c.CompletedAt), lo.Ternary(c.ResultID.Valid == false, nil, &c.ResultID), lo.Ternary(c.ErrorMessage.Valid == false, nil, &c.ErrorMessage), lo.Ternary(c.ErrorCode.Valid == false, nil, &c.ErrorCode)); err != nil {
		return logerror(err)
	}
	// set exists
	c._exists = true
	return nil
}

// Delete deletes the [Collection] from the database.
func (c *Collection) Delete(ctx context.Context, db DB) error {
	switch {
	case !c._exists: // doesn't exist
		return nil
	case c._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.collections ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, c.ID)
	if _, err := db.Exec(ctx, sqlstr, c.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	c._deleted = true
	return nil
}

// CollectionByID retrieves a row from 'public.collections' as a [Collection].
//
// Generated from index 'collections_pkey'.
func CollectionByID(ctx context.Context, db DB, id int64) (*Collection, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, status, request_count_limit, request_duration_limit, criteria, request_count, created_at, started_at, updated_at, completed_at, result_id, error_message, error_code ` +
		`FROM public.collections ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, id)
	c := Collection{
		_exists: true,
	}
	if err := db.QueryRow(ctx, sqlstr, id).Scan(&c.ID, &c.Status, &c.RequestCountLimit, &c.RequestDurationLimit, &c.Criteria, &c.RequestCount, &c.CreatedAt, &c.StartedAt, &c.UpdatedAt, &c.CompletedAt, &c.ResultID, &c.ErrorMessage, &c.ErrorCode); err != nil {
		return nil, logerror(err)
	}
	return &c, nil
}

// CollectionByIDs retrieves a row from 'public.collections' as a [Collection].
//
// Generated from index 'collections_pkey'.
func CollectionByIDs(ctx context.Context, db DB, id []int64) ([]*Collection, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, status, request_count_limit, request_duration_limit, criteria, request_count, created_at, started_at, updated_at, completed_at, result_id, error_message, error_code ` +
		`FROM public.collections ` +
		`WHERE id = ANY($1) ` +
		`ORDER BY id`
	// run
	logf(sqlstr, id)

	rows, err := db.Query(ctx, sqlstr, id)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Collection
	for rows.Next() {
		c := Collection{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&c.ID, &c.Status, &c.RequestCountLimit, &c.RequestDurationLimit, &c.Criteria, &c.RequestCount, &c.CreatedAt, &c.StartedAt, &c.UpdatedAt, &c.CompletedAt, &c.ResultID, &c.ErrorMessage, &c.ErrorCode); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &c)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// CollectionsByCompletedAt retrieves a row from 'public.collections' as a [Collection].
//
// Generated from index 'idx_collections_completed_at'.
func CollectionsByCompletedAt(ctx context.Context, db DB, completedAt pgtype.Timestamptz) ([]*Collection, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, status, request_count_limit, request_duration_limit, criteria, request_count, created_at, started_at, updated_at, completed_at, result_id, error_message, error_code ` +
		`FROM public.collections ` +
		`WHERE completed_at = $1`
	// run
	logf(sqlstr, completedAt)
	rows, err := db.Query(ctx, sqlstr, completedAt)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Collection
	for rows.Next() {
		c := Collection{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&c.ID, &c.Status, &c.RequestCountLimit, &c.RequestDurationLimit, &c.Criteria, &c.RequestCount, &c.CreatedAt, &c.StartedAt, &c.UpdatedAt, &c.CompletedAt, &c.ResultID, &c.ErrorMessage, &c.ErrorCode); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &c)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// CollectionsByCompletedAts retrieves a row from 'public.collections' as a [Collection].
//
// Generated from index 'idx_collections_completed_at'.
func CollectionsByCompletedAts(ctx context.Context, db DB, completedAt []pgtype.Timestamptz) ([]*Collection, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, status, request_count_limit, request_duration_limit, criteria, request_count, created_at, started_at, updated_at, completed_at, result_id, error_message, error_code ` +
		`FROM public.collections ` +
		`WHERE completed_at = ANY($1) ` +
		`ORDER BY completed_at`
	// run
	logf(sqlstr, completedAt)

	rows, err := db.Query(ctx, sqlstr, completedAt)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Collection
	for rows.Next() {
		c := Collection{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&c.ID, &c.Status, &c.RequestCountLimit, &c.RequestDurationLimit, &c.Criteria, &c.RequestCount, &c.CreatedAt, &c.StartedAt, &c.UpdatedAt, &c.CompletedAt, &c.ResultID, &c.ErrorMessage, &c.ErrorCode); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &c)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// CollectionsByCreatedAt retrieves a row from 'public.collections' as a [Collection].
//
// Generated from index 'idx_collections_created_at'.
func CollectionsByCreatedAt(ctx context.Context, db DB, createdAt time.Time) ([]*Collection, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, status, request_count_limit, request_duration_limit, criteria, request_count, created_at, started_at, updated_at, completed_at, result_id, error_message, error_code ` +
		`FROM public.collections ` +
		`WHERE created_at = $1`
	// run
	logf(sqlstr, createdAt)
	rows, err := db.Query(ctx, sqlstr, createdAt)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Collection
	for rows.Next() {
		c := Collection{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&c.ID, &c.Status, &c.RequestCountLimit, &c.RequestDurationLimit, &c.Criteria, &c.RequestCount, &c.CreatedAt, &c.StartedAt, &c.UpdatedAt, &c.CompletedAt, &c.ResultID, &c.ErrorMessage, &c.ErrorCode); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &c)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// CollectionsByCreatedAts retrieves a row from 'public.collections' as a [Collection].
//
// Generated from index 'idx_collections_created_at'.
func CollectionsByCreatedAts(ctx context.Context, db DB, createdAt []time.Time) ([]*Collection, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, status, request_count_limit, request_duration_limit, criteria, request_count, created_at, started_at, updated_at, completed_at, result_id, error_message, error_code ` +
		`FROM public.collections ` +
		`WHERE created_at = ANY($1) ` +
		`ORDER BY created_at`
	// run
	logf(sqlstr, createdAt)

	rows, err := db.Query(ctx, sqlstr, createdAt)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Collection
	for rows.Next() {
		c := Collection{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&c.ID, &c.Status, &c.RequestCountLimit, &c.RequestDurationLimit, &c.Criteria, &c.RequestCount, &c.CreatedAt, &c.StartedAt, &c.UpdatedAt, &c.CompletedAt, &c.ResultID, &c.ErrorMessage, &c.ErrorCode); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &c)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// CollectionsByStatus retrieves a row from 'public.collections' as a [Collection].
//
// Generated from index 'idx_collections_status'.
func CollectionsByStatus(ctx context.Context, db DB, status int) ([]*Collection, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, status, request_count_limit, request_duration_limit, criteria, request_count, created_at, started_at, updated_at, completed_at, result_id, error_message, error_code ` +
		`FROM public.collections ` +
		`WHERE status = $1`
	// run
	logf(sqlstr, status)
	rows, err := db.Query(ctx, sqlstr, status)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Collection
	for rows.Next() {
		c := Collection{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&c.ID, &c.Status, &c.RequestCountLimit, &c.RequestDurationLimit, &c.Criteria, &c.RequestCount, &c.CreatedAt, &c.StartedAt, &c.UpdatedAt, &c.CompletedAt, &c.ResultID, &c.ErrorMessage, &c.ErrorCode); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &c)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// CollectionsByStatuss retrieves a row from 'public.collections' as a [Collection].
//
// Generated from index 'idx_collections_status'.
func CollectionsByStatuss(ctx context.Context, db DB, status []int) ([]*Collection, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, status, request_count_limit, request_duration_limit, criteria, request_count, created_at, started_at, updated_at, completed_at, result_id, error_message, error_code ` +
		`FROM public.collections ` +
		`WHERE status = ANY($1) ` +
		`ORDER BY status`
	// run
	logf(sqlstr, status)

	rows, err := db.Query(ctx, sqlstr, status)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Collection
	for rows.Next() {
		c := Collection{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&c.ID, &c.Status, &c.RequestCountLimit, &c.RequestDurationLimit, &c.Criteria, &c.RequestCount, &c.CreatedAt, &c.StartedAt, &c.UpdatedAt, &c.CompletedAt, &c.ResultID, &c.ErrorMessage, &c.ErrorCode); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &c)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}
